<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU Animated Shader</title>
    <style>
        body {
            margin: 0;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            width: 600px;
            height: 400px;
        }
    </style>
</head>
<body>
    <canvas id="gpu-canvas"></canvas>
    <script type="module">
        async function init() {
            if (!navigator.gpu) {
                alert("WebGPU not supported in this browser!");
                return;
            }

            const canvas = document.getElementById("gpu-canvas");
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            // WGSL shader: fullscreen triangle + animated fragment
            const shader = device.createShaderModule({
                code: `
                   struct Uniforms {
                      time : f32
                   };
                   @binding(0) @group(0) var<uniform> uniforms : Uniforms;

                   @vertex
                   fn vs_main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {
                      var pos = array<vec2<f32>, 6>(
                         vec2<f32>(-1.0, -1.0),
                         vec2<f32>( 1.0, -1.0),
                         vec2<f32>(-1.0,  1.0),
                         vec2<f32>(-1.0,  1.0),
                         vec2<f32>( 1.0, -1.0),
                         vec2<f32>( 1.0,  1.0)
                      );
                      return vec4<f32>(pos[VertexIndex], 0.0, 1.0);
                   }

                   @fragment
                   fn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
                      let uv = fragCoord.xy / vec2<f32>(600.0, 400.0); // normalize coords
                      let t = uniforms.time * 0.001;

                      let wave = sin(uv.x * 10.0 + t) + cos(uv.y * 10.0 - t);
                      let r = 0.5 + 0.5 * sin(wave + t);
                      let g = 0.5 + 0.5 * sin(wave * 0.7 + t * 1.2);
                      let b = 0.5 + 0.5 * cos(wave * 1.3 - t * 0.8);

                      return vec4<f32>(r, g, b, 1.0);
                   }
                `
            });

            // Uniform buffer (time)
            const uniformBuffer = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: "uniform" }
                }]
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: { module: shader, entryPoint: "vs_main" },
                fragment: { module: shader, entryPoint: "fs_main", targets: [{ format }] },
                primitive: { topology: "triangle-list" }
            });

            function frame(time) {
                device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([time]));

                const encoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0, g: 0, b: 0, a: 1 },
                        loadOp: "clear",
                        storeOp: "store"
                    }]
                });

                pass.setPipeline(pipeline);
                pass.setBindGroup(0, bindGroup);
                pass.draw(6);
                pass.end();

                device.queue.submit([encoder.finish()]);
                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
        }

        init();
    </script>
</body>
</html>
